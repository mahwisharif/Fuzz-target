# Fuzz-target
Generation of fuzz target by prompting LLM 

## Prompt
Your task is to write a fuzz target for the provided function signature using `LLVMFuzzerTestOneInput()` to work with libFuzzer.

The function under test is as follows:

```
unsigned kTest_bug(KTest *bo) {
   unsigned i, res = 0;
   for (i = 0; i < bo->numObjects; i++)
      res += bo->objects[i].numBytes;
   return (bo->numObjects != 3) || (100 / (res - 7) != 3);
}
```
     
Additional Context:

The `kTest_bug` function is located in the kTest.c file.
Its signature is declared in the kTest.h file, which also contains the following struct definitions:

```
typedef struct KTestObject KTestObject;
struct KTestObject {
  char *name;
  unsigned numBytes;
  unsigned char *bytes;
};

typedef struct KTest KTest;
struct KTest {
   unsigned version;
   unsigned numArgs;
   char **args;
   unsigned symArgvs;
   unsigned symArgvLen;
   unsigned numObjects;
   KTestObject *objects;
};
```

Your goal:   

Write a fuzz target in the style of libFuzzer. The fuzz target should:
- Be implemented in the function int `LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)`.
- Convert the input data into a structure or format suitable for calling `kTest_bug`.
- Ensure that the generated fuzz target  builds and compiles correctly with the target code provided.

Further Guidelines:
- Carefully analyse the code to determine the type of vulnerability it may have, and how it can be triggered best 
- Return only the code , any comments should only be included as c-style comments.
- Exclude `extern "C"` from your response.
- The code should be self-contained and compatible with the provided function and struct definitions.

## Fuzz Target Generated by ChatGPT
```

#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include "KTest.h"


int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
    if (Size < sizeof(unsigned)) {
        // Not enough data to parse numObjects
        return 0;
    }

    // Extract numObjects from the input data
    unsigned numObjects = *(const unsigned *)Data;
    Data += sizeof(unsigned);
    Size -= sizeof(unsigned);

    // Allocate memory for KTest and initialize
    KTest bo;
    bo.version = 0;
    bo.numArgs = 0;
    bo.args = NULL;
    bo.symArgvs = 0;
    bo.symArgvLen = 0;
    bo.numObjects = numObjects;

    bo.objects = (KTestObject *)malloc(numObjects * sizeof(KTestObject));
    if (bo.objects == NULL) {
        return 0; // Memory allocation failed
    }

    // Initialize objects with available data
    for (unsigned i = 0; i < numObjects; i++) {
        if (Size < sizeof(unsigned)) {

            // Not enough data to parse numBytes
            bo.objects[i].name = NULL;
            bo.objects[i].numBytes = 0;
            bo.objects[i].bytes = NULL;
            continue;
        }

        // Extract numBytes from the input data
        unsigned numBytes = *(const unsigned *)Data;
        Data += sizeof(unsigned);
        Size -= sizeof(unsigned);

        bo.objects[i].name = NULL; // Name is unused in kTest_bug
        bo.objects[i].numBytes = numBytes;

        // Allocate and fill bytes array if enough data is available
        if (Size >= numBytes) {
            bo.objects[i].bytes = (unsigned char *)malloc(numBytes);
            if (bo.objects[i].bytes != NULL) {
                memcpy(bo.objects[i].bytes, Data, numBytes);
            }
            Data += numBytes;
            Size -= numBytes;
        } else {
            bo.objects[i].bytes = NULL;
        }
    }

    // Call the function under test
    (void)kTest_bug(&bo);

    // Free allocated memory
    for (unsigned i = 0; i < numObjects; i++) {
        free(bo.objects[i].bytes);
    }
    free(bo.objects);

    return 0;
}
```




 
